"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.UpdateAadAppDriver = void 0;
const tslib_1 = require("tslib");
const typedi_1 = require("typedi");
const invalidParameterUserError_1 = require("./error/invalidParameterUserError");
const fs = tslib_1.__importStar(require("fs-extra"));
const path = tslib_1.__importStar(require("path"));
const aadAppClient_1 = require("./utility/aadAppClient");
const axios_1 = tslib_1.__importDefault(require("axios"));
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const unhandledError_1 = require("./error/unhandledError");
const tools_1 = require("../../../common/tools");
const common_1 = require("../../utils/common");
const aadManifestHelper_1 = require("../../resource/aadApp/utils/aadManifestHelper");
const invalidFieldInManifestError_1 = require("./error/invalidFieldInManifestError");
const isUUID_1 = tslib_1.__importDefault(require("validator/lib/isUUID"));
const lib_1 = require("@feathersjs/hooks/lib");
const addStartAndEndTelemetry_1 = require("../middleware/addStartAndEndTelemetry");
const localizeUtils_1 = require("../../../common/localizeUtils");
const constants_1 = require("./utility/constants");
const missingEnvError_1 = require("./error/missingEnvError");
const actionName = "aadApp/update"; // DO NOT MODIFY the name
const helpLink = "https://aka.ms/teamsfx-actions/aadapp-update";
const driverConstants = {
    generateManifestFailedMessageKey: "driver.aadApp.error.generateManifestFailed",
};
// logic from src\component\resource\aadApp\aadAppManifestManager.ts
let UpdateAadAppDriver = class UpdateAadAppDriver {
    constructor() {
        this.description = localizeUtils_1.getLocalizedString(constants_1.descriptionMessageKeys.update);
    }
    async run(args, context) {
        const result = await this.execute(args, context);
        return result.result;
    }
    async execute(args, context) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        const progressBarSettings = this.getProgressBarSetting();
        const progressHandler = (_a = context.ui) === null || _a === void 0 ? void 0 : _a.createProgressBar(progressBarSettings.title, progressBarSettings.stepMessages.length);
        const summaries = [];
        try {
            await (progressHandler === null || progressHandler === void 0 ? void 0 : progressHandler.start());
            await (progressHandler === null || progressHandler === void 0 ? void 0 : progressHandler.next(progressBarSettings.stepMessages.shift()));
            (_b = context.logProvider) === null || _b === void 0 ? void 0 : _b.info(localizeUtils_1.getLocalizedString(constants_1.logMessageKeys.startExecuteDriver, actionName));
            this.validateArgs(args);
            const aadAppClient = new aadAppClient_1.AadAppClient(context.m365TokenProvider);
            const state = this.loadCurrentState();
            const manifestAbsolutePath = this.getAbsolutePath(args.manifestTemplatePath, context.projectPath);
            const manifest = await this.loadManifest(manifestAbsolutePath, state);
            const warningMessage = aadManifestHelper_1.AadManifestHelper.validateManifest(manifest);
            if (warningMessage) {
                warningMessage.split("\n").forEach((warning) => {
                    var _a;
                    (_a = context.logProvider) === null || _a === void 0 ? void 0 : _a.warning(warning);
                });
            }
            if (!manifest.id || !isUUID_1.default(manifest.id)) {
                throw new invalidFieldInManifestError_1.MissingFieldInManifestUserError(actionName, "id", helpLink);
            }
            // Output actual manifest to project folder first for better troubleshooting experience
            const outputFileAbsolutePath = this.getAbsolutePath(args.outputFilePath, context.projectPath);
            await fs.ensureDir(path.dirname(outputFileAbsolutePath));
            await fs.writeFile(outputFileAbsolutePath, JSON.stringify(manifest, null, 4), "utf8");
            (_c = context.logProvider) === null || _c === void 0 ? void 0 : _c.info(localizeUtils_1.getLocalizedString(constants_1.logMessageKeys.outputAadAppManifest, outputFileAbsolutePath));
            // MS Graph API does not allow adding new OAuth permissions and pre authorize it within one request
            // So split update AAD app to two requests:
            // 1. If there's preAuthorizedApplications, remove it temporary and update AAD app to create possible new permission
            if (manifest.preAuthorizedApplications && manifest.preAuthorizedApplications.length > 0) {
                const preAuthorizedApplications = manifest.preAuthorizedApplications;
                manifest.preAuthorizedApplications = [];
                await aadAppClient.updateAadApp(manifest);
                manifest.preAuthorizedApplications = preAuthorizedApplications;
            }
            // 2. Update AAD app again with full manifest to set preAuthorizedApplications
            await aadAppClient.updateAadApp(manifest);
            const summary = localizeUtils_1.getLocalizedString(constants_1.logMessageKeys.successUpdateAadAppManifest, args.manifestTemplatePath, manifest.id);
            (_d = context.logProvider) === null || _d === void 0 ? void 0 : _d.info(summary);
            summaries.push(summary);
            (_e = context.logProvider) === null || _e === void 0 ? void 0 : _e.info(localizeUtils_1.getLocalizedString(constants_1.logMessageKeys.successExecuteDriver, actionName));
            await (progressHandler === null || progressHandler === void 0 ? void 0 : progressHandler.end(true));
            return {
                result: teamsfx_api_1.ok(new Map(Object.entries(state) // convert each property to Map item
                    .filter((item) => item[1] && item[1] !== "") // do not return Map item that is empty
                )),
                summaries: summaries,
            };
        }
        catch (error) {
            await (progressHandler === null || progressHandler === void 0 ? void 0 : progressHandler.end(false));
            if (error instanceof teamsfx_api_1.UserError || error instanceof teamsfx_api_1.SystemError) {
                (_f = context.logProvider) === null || _f === void 0 ? void 0 : _f.error(localizeUtils_1.getLocalizedString(constants_1.logMessageKeys.failExecuteDriver, actionName, error.displayMessage));
                return {
                    result: teamsfx_api_1.err(error),
                    summaries: summaries,
                };
            }
            if (axios_1.default.isAxiosError(error)) {
                const message = JSON.stringify(error.response.data);
                (_g = context.logProvider) === null || _g === void 0 ? void 0 : _g.error(localizeUtils_1.getLocalizedString(constants_1.logMessageKeys.failExecuteDriver, actionName, message));
                if (error.response.status >= 400 && error.response.status < 500) {
                    return {
                        result: teamsfx_api_1.err(new unhandledError_1.UnhandledUserError(actionName, message, helpLink)),
                        summaries: summaries,
                    };
                }
                else {
                    return {
                        result: teamsfx_api_1.err(new unhandledError_1.UnhandledSystemError(actionName, message)),
                        summaries: summaries,
                    };
                }
            }
            const message = JSON.stringify(error);
            (_h = context.logProvider) === null || _h === void 0 ? void 0 : _h.error(localizeUtils_1.getLocalizedString(constants_1.logMessageKeys.failExecuteDriver, actionName, message));
            return {
                result: teamsfx_api_1.err(new unhandledError_1.UnhandledSystemError(actionName, JSON.stringify(error))),
                summaries: summaries,
            };
        }
    }
    validateArgs(args) {
        const invalidParameters = [];
        if (typeof args.manifestTemplatePath !== "string" || !args.manifestTemplatePath) {
            invalidParameters.push("manifestTemplatePath");
        }
        if (typeof args.outputFilePath !== "string" || !args.outputFilePath) {
            invalidParameters.push("outputFilePath");
        }
        if (invalidParameters.length > 0) {
            throw new invalidParameterUserError_1.InvalidParameterUserError(actionName, invalidParameters, helpLink);
        }
    }
    loadCurrentState() {
        return {
            AAD_APP_ACCESS_AS_USER_PERMISSION_ID: process.env.AAD_APP_ACCESS_AS_USER_PERMISSION_ID,
        };
    }
    async loadManifest(manifestPath, state) {
        let generatedNewPermissionId = false;
        try {
            const manifestTemplate = await fs.readFile(manifestPath, "utf8");
            const permissionIdPlaceholderRegex = /\${{ *AAD_APP_ACCESS_AS_USER_PERMISSION_ID *}}/;
            // generate a new permission id if there's no one in env and manifest needs it
            if (!process.env.AAD_APP_ACCESS_AS_USER_PERMISSION_ID) {
                const matches = permissionIdPlaceholderRegex.exec(manifestTemplate);
                if (matches) {
                    const permissionId = tools_1.getUuid();
                    process.env.AAD_APP_ACCESS_AS_USER_PERMISSION_ID = permissionId;
                    state.AAD_APP_ACCESS_AS_USER_PERMISSION_ID = permissionId;
                    generatedNewPermissionId = true;
                }
            }
            const manifestString = common_1.expandEnvironmentVariable(manifestTemplate);
            this.validateManifestString(manifestString);
            const manifest = JSON.parse(manifestString);
            aadManifestHelper_1.AadManifestHelper.processRequiredResourceAccessInManifest(manifest);
            return manifest;
        }
        finally {
            if (generatedNewPermissionId) {
                // restore environment variable to avoid impact to other code
                delete process.env.AAD_APP_ACCESS_AS_USER_PERMISSION_ID;
            }
        }
    }
    getAbsolutePath(relativeOrAbsolutePath, projectPath) {
        return path.isAbsolute(relativeOrAbsolutePath)
            ? relativeOrAbsolutePath
            : path.join(projectPath, relativeOrAbsolutePath);
    }
    getProgressBarSetting() {
        return {
            title: localizeUtils_1.getLocalizedString("driver.aadApp.progressBar.updateAadAppTitle"),
            stepMessages: [
                localizeUtils_1.getLocalizedString("driver.aadApp.progressBar.updateAadAppStepMessage"), // step 1
            ],
        };
    }
    validateManifestString(manifestString) {
        const unresolvedEnvironmentVariable = common_1.getEnvironmentVariables(manifestString);
        if (unresolvedEnvironmentVariable && unresolvedEnvironmentVariable.length > 0) {
            throw new missingEnvError_1.MissingEnvUserError(actionName, unresolvedEnvironmentVariable, helpLink, driverConstants.generateManifestFailedMessageKey);
        }
    }
};
tslib_1.__decorate([
    lib_1.hooks([addStartAndEndTelemetry_1.addStartAndEndTelemetry(actionName, actionName)]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], UpdateAadAppDriver.prototype, "execute", null);
UpdateAadAppDriver = tslib_1.__decorate([
    typedi_1.Service(actionName) // DO NOT MODIFY the service name
], UpdateAadAppDriver);
exports.UpdateAadAppDriver = UpdateAadAppDriver;
//# sourceMappingURL=update.js.map