"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.AzureDeployDriver = void 0;
const tslib_1 = require("tslib");
const common_1 = require("../../../utils/common");
const deployError_1 = require("../../../error/deployError");
const baseDeployDriver_1 = require("./baseDeployDriver");
const js_base64_1 = require("js-base64");
const appService = tslib_1.__importStar(require("@azure/arm-appservice"));
const deployConstant_1 = require("../../../constant/deployConstant");
const axios_1 = tslib_1.__importDefault(require("axios"));
const tools_1 = require("../../../../common/tools");
const commonConstant_1 = require("../../../constant/commonConstant");
const azureResourceOperation_1 = require("../../../utils/azureResourceOperation");
const messages_1 = require("../../../messages");
const fs = tslib_1.__importStar(require("fs-extra"));
const componentError_1 = require("../../../error/componentError");
class AzureDeployDriver extends baseDeployDriver_1.BaseDeployDriver {
    async deploy(args) {
        // check root path exists
        if (!(await fs.pathExists(this.workingDirectory))) {
            throw componentError_1.PrerequisiteError.folderNotExists(deployConstant_1.DeployConstant.DEPLOY_ERROR_TYPE, this.workingDirectory, this.helpLink);
        }
        // check distribution folder exists
        if (!(await fs.pathExists(this.distDirectory))) {
            throw componentError_1.PrerequisiteError.folderNotExists(deployConstant_1.DeployConstant.DEPLOY_ERROR_TYPE, this.distDirectory, this.helpLink);
        }
        const resourceId = common_1.checkMissingArgs("resourceId", args.resourceId);
        const azureResource = this.parseResourceId(resourceId);
        const azureCredential = await azureResourceOperation_1.getAzureAccountCredential(this.context.azureAccountProvider);
        return await this.azureDeploy({ ignoreFile: args.ignoreFile }, azureResource, azureCredential);
    }
    /**
     * check if resource id is legal and parse it
     * @param resourceId deploy target
     * @protected
     */
    parseResourceId(resourceId) {
        return azureResourceOperation_1.parseAzureResourceId(resourceId, this.pattern);
    }
    /**
     * deploy to azure app service or azure function use zip deploy method
     * @param args local file needed to be deployed
     * @param azureResource azure resource info
     * @param azureCredential azure user login credential
     * @return the zip deploy time cost
     * @protected
     */
    async zipDeploy(args, azureResource, azureCredential) {
        var _a, _b, _c, _d, _e;
        await ((_a = this.progressBar) === null || _a === void 0 ? void 0 : _a.next(messages_1.ProgressMessages.packingCode));
        const zipBuffer = await this.packageToZip(args, this.context);
        await ((_b = this.progressBar) === null || _b === void 0 ? void 0 : _b.next(messages_1.ProgressMessages.getAzureAccountInfoForDeploy));
        await this.context.logProvider.debug("Start to get Azure account info for deploy");
        const config = await this.createAzureDeployConfig(azureResource, azureCredential);
        await this.context.logProvider.debug("Get Azure account info for deploy complete");
        await ((_c = this.progressBar) === null || _c === void 0 ? void 0 : _c.next(messages_1.ProgressMessages.getAzureUploadEndpoint));
        const endpoint = this.getZipDeployEndpoint(azureResource.instanceId);
        await this.context.logProvider.debug(`Start to upload code to ${endpoint}`);
        await ((_d = this.progressBar) === null || _d === void 0 ? void 0 : _d.next(messages_1.ProgressMessages.uploadZipFileToAzure));
        const startTime = Date.now();
        const location = await this.zipDeployPackage(endpoint, zipBuffer, config, this.context.logProvider);
        await this.context.logProvider.debug("Upload code to Azure complete");
        await ((_e = this.progressBar) === null || _e === void 0 ? void 0 : _e.next(messages_1.ProgressMessages.checkAzureDeployStatus));
        await this.context.logProvider.debug("Start to check Azure deploy status");
        await this.checkDeployStatus(location, config, this.context.logProvider);
        await this.context.logProvider.debug("Check Azure deploy status complete");
        return Date.now() - startTime;
    }
    /**
     * call azure app service or azure function zip deploy method
     * @param zipDeployEndpoint azure zip deploy endpoint
     * @param zipBuffer zip file buffer
     * @param config azure upload config, including azure account credential
     * @param logger log provider
     * @protected
     */
    async zipDeployPackage(zipDeployEndpoint, zipBuffer, config, logger) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        let res;
        let retryCount = 0;
        while (true) {
            try {
                res = await AzureDeployDriver.AXIOS_INSTANCE.post(zipDeployEndpoint, zipBuffer, config);
                break;
            }
            catch (e) {
                if (axios_1.default.isAxiosError(e)) {
                    // if the error is remote server error, retry
                    if (((_b = (_a = e.response) === null || _a === void 0 ? void 0 : _a.status) !== null && _b !== void 0 ? _b : 200) >= 500) {
                        retryCount += 1;
                        if (retryCount < deployConstant_1.DeployConstant.DEPLOY_UPLOAD_RETRY_TIMES) {
                            await (logger === null || logger === void 0 ? void 0 : logger.warning(`Upload zip file failed with response status code: ${(_d = (_c = e.response) === null || _c === void 0 ? void 0 : _c.status) !== null && _d !== void 0 ? _d : "NA"}. Retrying...`));
                        }
                        else {
                            // if retry times exceed, throw error
                            await (logger === null || logger === void 0 ? void 0 : logger.warning(`Retry times exceeded. Upload zip file failed with remote server error. Message: ${JSON.stringify((_e = e.response) === null || _e === void 0 ? void 0 : _e.data)}`));
                            throw deployError_1.DeployExternalApiCallError.zipDeployWithRemoteError(e, undefined, this.helpLink);
                        }
                    }
                    else {
                        // None server error, throw
                        await (logger === null || logger === void 0 ? void 0 : logger.error(`Upload zip file failed with response status code: ${(_g = (_f = e.response) === null || _f === void 0 ? void 0 : _f.status) !== null && _g !== void 0 ? _g : "NA"}, message: ${JSON.stringify((_h = e.response) === null || _h === void 0 ? void 0 : _h.data)}`));
                        throw deployError_1.DeployExternalApiCallError.zipDeployError(e, (_k = (_j = e.response) === null || _j === void 0 ? void 0 : _j.status) !== null && _k !== void 0 ? _k : -1, this.helpLink);
                    }
                }
                else {
                    // if the error is not axios error, throw
                    await (logger === null || logger === void 0 ? void 0 : logger.error(`Upload zip file failed with error: ${JSON.stringify(e)}`));
                    throw deployError_1.DeployExternalApiCallError.zipDeployError(e, -1, this.helpLink);
                }
            }
        }
        if ((res === null || res === void 0 ? void 0 : res.status) !== commonConstant_1.HttpStatusCode.OK && (res === null || res === void 0 ? void 0 : res.status) !== commonConstant_1.HttpStatusCode.ACCEPTED) {
            if (res === null || res === void 0 ? void 0 : res.status) {
                await (logger === null || logger === void 0 ? void 0 : logger.error(`Deployment is failed with error code: ${res.status}.`));
            }
            throw deployError_1.DeployExternalApiCallError.zipDeployError(res, res.status, this.helpLink);
        }
        return res.headers.location;
    }
    /**
     * loop and check azure deployment status
     * by default, it will wait for 120 minutes
     * @param location azure deployment location
     * @param config azure upload config, including azure account credential
     * @param logger log provider
     * @protected
     */
    async checkDeployStatus(location, config, logger) {
        var _a, _b, _c;
        let res;
        for (let i = 0; i < deployConstant_1.DeployConstant.DEPLOY_CHECK_RETRY_TIMES; ++i) {
            try {
                res = await AzureDeployDriver.AXIOS_INSTANCE.get(location, config);
            }
            catch (e) {
                if (axios_1.default.isAxiosError(e)) {
                    await (logger === null || logger === void 0 ? void 0 : logger.error(`Check deploy status failed with response status code: ${(_b = (_a = e.response) === null || _a === void 0 ? void 0 : _a.status) !== null && _b !== void 0 ? _b : "NA"}, message: ${JSON.stringify((_c = e.response) === null || _c === void 0 ? void 0 : _c.data)}`));
                }
                throw deployError_1.DeployExternalApiCallError.deployStatusError(e, undefined, this.helpLink);
            }
            if (res) {
                if ((res === null || res === void 0 ? void 0 : res.status) === commonConstant_1.HttpStatusCode.ACCEPTED) {
                    await tools_1.waitSeconds(deployConstant_1.DeployConstant.BACKOFF_TIME_S);
                }
                else if ((res === null || res === void 0 ? void 0 : res.status) === commonConstant_1.HttpStatusCode.OK || (res === null || res === void 0 ? void 0 : res.status) === commonConstant_1.HttpStatusCode.CREATED) {
                    return;
                }
                else {
                    if (res.status) {
                        await (logger === null || logger === void 0 ? void 0 : logger.error(`Deployment is failed with error code: ${res.status}.`));
                    }
                    throw deployError_1.DeployExternalApiCallError.deployStatusError(res, res.status, this.helpLink);
                }
            }
        }
        throw deployError_1.DeployTimeoutError.checkDeployStatusTimeout(this.helpLink);
    }
    /**
     * create azure zip deploy endpoint
     * @param siteName azure app service or azure function name
     * @protected
     */
    getZipDeployEndpoint(siteName) {
        return `https://${siteName}.scm.azurewebsites.net/api/zipdeploy?isAsync=true`;
    }
    /**
     * create azure deploy config for Azure Function and Azure App service
     * @param azureResource azure resource info
     * @param azureCredential user azure credential
     * @protected
     */
    async createAzureDeployConfig(azureResource, azureCredential) {
        var _a, _b;
        this.managementClient = new appService.WebSiteManagementClient(azureCredential, azureResource.subscriptionId);
        let listResponse;
        try {
            listResponse = await this.managementClient.webApps.beginListPublishingCredentialsAndWait(azureResource.resourceGroupName, azureResource.instanceId);
        }
        catch (e) {
            throw deployError_1.DeployExternalApiCallError.listPublishingCredentialsError(e, this.helpLink);
        }
        const publishingUserName = (_a = listResponse.publishingUserName) !== null && _a !== void 0 ? _a : "";
        const publishingPassword = (_b = listResponse.publishingPassword) !== null && _b !== void 0 ? _b : "";
        const encryptedCredentials = js_base64_1.Base64.encode(`${publishingUserName}:${publishingPassword}`);
        return {
            headers: {
                "Content-Type": "application/octet-stream",
                "Cache-Control": "no-cache",
                Authorization: `Basic ${encryptedCredentials}`,
            },
            maxContentLength: Infinity,
            maxBodyLength: Infinity,
            timeout: deployConstant_1.DeployConstant.DEPLOY_TIMEOUT_IN_MS,
        };
    }
    async restartFunctionApp(azureResource) {
        var _a, _b;
        await this.context.logProvider.debug("Restarting function app...");
        try {
            await ((_b = (_a = this.managementClient) === null || _a === void 0 ? void 0 : _a.webApps) === null || _b === void 0 ? void 0 : _b.restart(azureResource.resourceGroupName, azureResource.instanceId));
        }
        catch (e) {
            throw deployError_1.DeployExternalApiCallError.restartWebAppError(e, this.helpLink);
        }
    }
}
exports.AzureDeployDriver = AzureDeployDriver;
AzureDeployDriver.AXIOS_INSTANCE = axios_1.default.create();
//# sourceMappingURL=azureDeployDriver.js.map