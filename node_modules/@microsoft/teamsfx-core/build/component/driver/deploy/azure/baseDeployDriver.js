"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseDeployDriver = void 0;
const tslib_1 = require("tslib");
const componentError_1 = require("../../../error/componentError");
const ignore_1 = tslib_1.__importDefault(require("ignore"));
const deployConstant_1 = require("../../../constant/deployConstant");
const path = tslib_1.__importStar(require("path"));
const fs = tslib_1.__importStar(require("fs-extra"));
const fileOperation_1 = require("../../../utils/fileOperation");
const common_1 = require("../../../utils/common");
const baseDeployStepDriver_1 = require("../../interface/baseDeployStepDriver");
class BaseDeployDriver extends baseDeployStepDriver_1.BaseDeployStepDriver {
    constructor() {
        super(...arguments);
        this.helpLink = undefined;
    }
    async run() {
        var _a;
        await this.context.logProvider.debug("start deploy process");
        const deployArgs = BaseDeployDriver.asDeployArgs(this.args, this.helpLink);
        // if working directory not set, use current working directory
        deployArgs.workingDirectory = (_a = deployArgs.workingDirectory) !== null && _a !== void 0 ? _a : "./";
        // if working dir is not absolute path, then join the path with project path
        this.workingDirectory = path.isAbsolute(deployArgs.workingDirectory)
            ? deployArgs.workingDirectory
            : path.join(this.workingDirectory, deployArgs.workingDirectory);
        // if distribution path is not absolute path, then join the path with project path
        this.distDirectory = path.isAbsolute(deployArgs.distributionPath)
            ? deployArgs.distributionPath
            : path.join(this.workingDirectory, deployArgs.distributionPath);
        // call real deploy
        await this.wrapErrorHandler(async () => {
            await this.deploy(deployArgs);
        });
        return BaseDeployDriver.emptyMap;
    }
    /**
     * pack dist folder into zip
     * @param args dist folder and ignore files
     * @param context log provider etc..
     * @protected
     */
    async packageToZip(args, context) {
        var _a, _b;
        const ig = await this.handleIgnore(args, context);
        const zipFilePath = path.join(this.workingDirectory, deployConstant_1.DeployConstant.DEPLOYMENT_TMP_FOLDER, deployConstant_1.DeployConstant.DEPLOYMENT_ZIP_CACHE_FILE);
        await ((_a = this.context.logProvider) === null || _a === void 0 ? void 0 : _a.debug(`start zip dist folder ${this.distDirectory}`));
        const res = await fileOperation_1.zipFolderAsync(this.distDirectory, zipFilePath, ig);
        await ((_b = this.context.logProvider) === null || _b === void 0 ? void 0 : _b.debug(`zip dist folder ${this.distDirectory} to ${zipFilePath} complete`));
        return res;
    }
    async handleIgnore(args, context) {
        // always add deploy temp folder into ignore list
        const ig = ignore_1.default().add(deployConstant_1.DeployConstant.DEPLOYMENT_TMP_FOLDER);
        if (args.ignoreFile) {
            const ignoreFilePath = path.join(this.workingDirectory, args.ignoreFile);
            if (await fs.pathExists(ignoreFilePath)) {
                const ignoreFileContent = await fs.readFile(ignoreFilePath);
                ignoreFileContent
                    .toString()
                    .split("\n")
                    .map((line) => line.trim())
                    .forEach((it) => {
                    ig.add(it);
                });
            }
            else {
                await context.logProvider.warning(`already set deploy ignore file ${args.ignoreFile} but file not exists in ${this.workingDirectory}, skip ignore!`);
            }
        }
        return ig;
    }
    async wrapErrorHandler(fn) {
        var _a;
        try {
            return Promise.resolve(fn());
        }
        catch (e) {
            await ((_a = this.context.progressBar) === null || _a === void 0 ? void 0 : _a.end(false));
            if (e instanceof componentError_1.BaseComponentInnerError) {
                const errorDetail = e.detail ? `Detail: ${e.detail}` : "";
                await this.context.logProvider.error(`${e.message} ${errorDetail}`);
                throw e.toFxError();
            }
            else {
                await this.context.logProvider.error(`Unknown error: ${e}`);
                throw e;
            }
        }
    }
}
exports.BaseDeployDriver = BaseDeployDriver;
BaseDeployDriver.emptyMap = new Map();
BaseDeployDriver.asDeployArgs = common_1.asFactory({
    workingDirectory: common_1.asOptional(common_1.asString),
    distributionPath: common_1.asString,
    ignoreFile: common_1.asOptional(common_1.asString),
    resourceId: common_1.asString,
});
//# sourceMappingURL=baseDeployDriver.js.map