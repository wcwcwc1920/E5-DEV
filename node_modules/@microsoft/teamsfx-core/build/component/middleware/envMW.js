"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EnvWriterMW = exports.envLoaderMWImpl = exports.EnvLoaderMW = void 0;
const tslib_1 = require("tslib");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const environment_1 = require("../../core/environment");
const error_1 = require("../../core/error");
const globalVars_1 = require("../../core/globalVars");
const question_1 = require("../question");
const envUtil_1 = require("../utils/envUtil");
const lodash_1 = tslib_1.__importDefault(require("lodash"));
const localizeUtils_1 = require("../../common/localizeUtils");
function EnvLoaderMW(withLocalEnv) {
    return async (ctx, next) => {
        const envBefore = lodash_1.default.cloneDeep(process.env);
        try {
            await exports.envLoaderMWImpl(withLocalEnv, ctx, next);
            return;
        }
        finally {
            const keys = Object.keys(process.env);
            for (const k of keys) {
                if (!(k in envBefore)) {
                    delete process.env[k];
                }
                else {
                    process.env[k] = envBefore[k];
                }
            }
        }
    };
}
exports.EnvLoaderMW = EnvLoaderMW;
const envLoaderMWImpl = async (withLocalEnv, ctx, next) => {
    const inputs = ctx.arguments[ctx.arguments.length - 1];
    const projectPath = inputs.projectPath;
    if (!projectPath) {
        ctx.result = teamsfx_api_1.err(new error_1.NoProjectOpenedError());
        return;
    }
    if (inputs.ignoreEnvInfo) {
        inputs.env = environment_1.environmentManager.getDefaultEnvName();
    }
    if (!inputs.env) {
        const question = question_1.SelectEnvQuestion;
        const envListRes = await envUtil_1.envUtil.listEnv(projectPath);
        if (envListRes.isErr()) {
            ctx.result = teamsfx_api_1.err(envListRes.error);
            return;
        }
        if (envListRes.value.length === 0) {
            ctx.result = teamsfx_api_1.err(new teamsfx_api_1.UserError({
                source: "EnvLoaderMW",
                name: "NoYmlFileError",
                displayMessage: localizeUtils_1.getLocalizedString("core.error.NoYmlFileError"),
                message: localizeUtils_1.getDefaultString("core.error.NoYmlFileError"),
            }));
            return;
        }
        if (withLocalEnv) {
            question.staticOptions = envListRes.value;
        }
        else {
            question.staticOptions = envListRes.value.filter((p) => p !== environment_1.environmentManager.getLocalEnvName());
        }
        const res = await teamsfx_api_1.traverse(new teamsfx_api_1.QTreeNode(question), inputs, globalVars_1.TOOLS.ui);
        if (res.isErr()) {
            globalVars_1.TOOLS.logProvider.debug(`[core:env] failed to run question model for target environment.`);
            ctx.result = teamsfx_api_1.err(res.error);
            return;
        }
        if (!inputs.env) {
            ctx.result = teamsfx_api_1.err(teamsfx_api_1.UserCancelError);
            return;
        }
    }
    const res = await envUtil_1.envUtil.readEnv(projectPath, inputs.env);
    if (res.isErr()) {
        ctx.result = teamsfx_api_1.err(res.error);
        return;
    }
    ctx.envVars = res.value;
    await next();
};
exports.envLoaderMWImpl = envLoaderMWImpl;
const EnvWriterMW = async (ctx, next) => {
    await next();
    const inputs = ctx.arguments[0];
    const env = inputs.env;
    const projectPath = inputs.projectPath;
    const envVars = ctx.envVars;
    if (projectPath && env && envVars) {
        const res = await envUtil_1.envUtil.writeEnv(projectPath, env, envVars);
        if (res.isErr()) {
            ctx.result = teamsfx_api_1.err(res.error);
            return;
        }
    }
};
exports.EnvWriterMW = EnvWriterMW;
//# sourceMappingURL=envMW.js.map