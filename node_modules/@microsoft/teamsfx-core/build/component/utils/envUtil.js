"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.dotenvUtil = exports.DotenvUtil = exports.envUtil = exports.EnvUtil = void 0;
const tslib_1 = require("tslib");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const path = tslib_1.__importStar(require("path"));
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const lodash_1 = require("lodash");
const settingsUtil_1 = require("./settingsUtil");
const crypto_1 = require("../../core/crypto");
const localizeUtils_1 = require("../../common/localizeUtils");
class EnvUtil {
    async readEnv(projectPath, env, loadToProcessEnv = true, silent = false) {
        // read
        const dotEnvFilePath = path.join(projectPath, teamsfx_api_1.SettingsFolderName, `.env.${env}`);
        if (!(await fs_extra_1.default.pathExists(dotEnvFilePath))) {
            if (silent) {
                return teamsfx_api_1.ok({});
            }
            else {
                return teamsfx_api_1.err(new teamsfx_api_1.UserError({
                    source: "core",
                    name: "DotEnvFileNotExistError",
                    displayMessage: localizeUtils_1.getLocalizedString("error.DotEnvFileNotExistError", env, env),
                    message: localizeUtils_1.getDefaultString("error.DotEnvFileNotExistError", env, env),
                }));
            }
        }
        // deserialize
        const parseResult = exports.dotenvUtil.deserialize(await fs_extra_1.default.readFile(dotEnvFilePath, { encoding: "utf8" }));
        // decrypt
        const settingsRes = await settingsUtil_1.settingsUtil.readSettings(projectPath);
        if (settingsRes.isErr()) {
            return teamsfx_api_1.err(settingsRes.error);
        }
        const projectId = settingsRes.value.trackingId;
        const cryptoProvider = new crypto_1.LocalCrypto(projectId);
        for (const key of Object.keys(parseResult.obj)) {
            if (key.startsWith("SECRET_")) {
                const raw = parseResult.obj[key];
                const decryptRes = await cryptoProvider.decrypt(raw);
                if (decryptRes.isErr())
                    return teamsfx_api_1.err(decryptRes.error);
                parseResult.obj[key] = decryptRes.value;
            }
        }
        parseResult.obj.TEAMSFX_ENV = env;
        if (loadToProcessEnv) {
            lodash_1.merge(process.env, parseResult.obj);
        }
        return teamsfx_api_1.ok(parseResult.obj);
    }
    async writeEnv(projectPath, env, envs) {
        //encrypt
        const settingsRes = await settingsUtil_1.settingsUtil.readSettings(projectPath);
        if (settingsRes.isErr()) {
            return teamsfx_api_1.err(settingsRes.error);
        }
        const projectId = settingsRes.value.trackingId;
        const cryptoProvider = new crypto_1.LocalCrypto(projectId);
        for (const key of Object.keys(envs)) {
            let value = envs[key];
            if (value && key.startsWith("SECRET_")) {
                const res = await cryptoProvider.encrypt(value);
                if (res.isErr())
                    return teamsfx_api_1.err(res.error);
                value = res.value;
                envs[key] = value;
            }
        }
        //replace existing
        const dotEnvFilePath = path.join(projectPath, teamsfx_api_1.SettingsFolderName, `.env.${env}`);
        const parsedDotenv = (await fs_extra_1.default.pathExists(dotEnvFilePath))
            ? exports.dotenvUtil.deserialize(await fs_extra_1.default.readFile(dotEnvFilePath))
            : { obj: {} };
        parsedDotenv.obj = envs;
        //serialize
        const content = exports.dotenvUtil.serialize(parsedDotenv);
        //persist
        await fs_extra_1.default.writeFile(dotEnvFilePath, content, { encoding: "utf8" });
        return teamsfx_api_1.ok(undefined);
    }
    async listEnv(projectPath) {
        const folder = path.join(projectPath, teamsfx_api_1.SettingsFolderName);
        const list = await fs_extra_1.default.readdir(folder);
        const envs = list
            .filter((fileName) => fileName.startsWith(".env."))
            .map((fileName) => fileName.substring(5));
        return teamsfx_api_1.ok(envs);
    }
    object2map(obj) {
        const map = new Map();
        for (const key of Object.keys(obj)) {
            map.set(key, obj[key]);
        }
        return map;
    }
    map2object(map) {
        const obj = {};
        for (const key of map.keys()) {
            obj[key] = map.get(key) || "";
        }
        return obj;
    }
}
exports.EnvUtil = EnvUtil;
exports.envUtil = new EnvUtil();
const KEY_VALUE_PAIR_RE = /^\s*([\w.-]+)\s*=\s*(.*)?\s*$/;
const NEW_LINE_RE = /\\n/g;
const NEW_LINE_SPLITTER = /\r?\n/;
const NEW_LINE = "\n";
class DotenvUtil {
    deserialize(src) {
        const lines = [];
        const obj = {};
        const stringLines = src.toString().split(NEW_LINE_SPLITTER);
        for (const line of stringLines) {
            const kvMatchArray = line.match(KEY_VALUE_PAIR_RE);
            if (kvMatchArray !== null) {
                // match key-value pair
                const key = kvMatchArray[1];
                let value = kvMatchArray[2] || "";
                let inlineComment;
                const dQuoted = value[0] === '"' && value[value.length - 1] === '"';
                const sQuoted = value[0] === "'" && value[value.length - 1] === "'";
                if (sQuoted || dQuoted) {
                    value = value.substring(1, value.length - 1);
                    if (dQuoted) {
                        value = value.replace(NEW_LINE_RE, NEW_LINE);
                    }
                }
                else {
                    value = value.trim();
                    //try to match comment starter
                    const index = value.indexOf("#");
                    if (index >= 0) {
                        inlineComment = value.substring(index);
                        value = value.substring(0, index).trim();
                    }
                }
                if (value)
                    obj[key] = value;
                lines.push(inlineComment
                    ? { key: key, value: value, comment: inlineComment }
                    : { key: key, value: value });
            }
            else {
                lines.push(line);
            }
        }
        return { lines: lines, obj: obj };
    }
    serialize(parsed) {
        const array = [];
        const obj = lodash_1.cloneDeep(parsed.obj);
        //append lines
        if (parsed.lines) {
            parsed.lines.forEach((line) => {
                if (typeof line === "string") {
                    // keep comment line or empty line
                    array.push(line);
                }
                else {
                    if (obj[line.key] !== undefined) {
                        // use kv in obj
                        array.push(`${line.key}=${obj[line.key]}${line.comment ? " " + line.comment : ""}`);
                        delete obj[line.key];
                    }
                    else {
                        // keep original kv in lines
                        array.push(`${line.key}=${line.value}${line.comment ? " " + line.comment : ""}`);
                    }
                }
            });
        }
        //append additional kvs
        for (const key of Object.keys(obj)) {
            array.push(`${key}=${parsed.obj[key]}`);
        }
        return array.join("\n").trim();
    }
}
exports.DotenvUtil = DotenvUtil;
exports.dotenvUtil = new DotenvUtil();
// const original = `# Built-in environment variables
// TEAMSFX_ENV=dev2
// AZURE_SUBSCRIPTION_ID=
// AZURE_RESOURCE_GROUP_NAME=
// RESOURCE_SUFFIX=
// # Generated during provision, you can also add your own variables. If you're adding a secret value, add SECRET_ prefix to the name so Teams Toolkit can handle them properly
// BOT_ID=
// SECRET_BOT_PASSWORD=
// TEAMS_APP_ID=
// BOT_AZURE_FUNCTION_APP_RESOURCE_ID=
// BOT_DOMAIN=
// BOT_FUNCTION_ENDPOINT=
// TEAMS_APP_TENANT_ID=
// `;
// const parsed = dotenvUtil.deserialize(original);
// console.log(parsed)
//# sourceMappingURL=envUtil.js.map