// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ImplementMyselfOption = exports.APIKeyAuthOption = exports.AADAuthOption = exports.CertAuthOption = exports.BasicAuthOption = exports.functionOption = exports.botOption = exports.queryParamsOption = exports.requestHeaderOption = exports.anotherAppOption = exports.reuseAppOption = exports.buildAPIKeyNameQuestion = exports.appIdQuestion = exports.appTenantIdQuestion = exports.basicAuthUsernameQuestion = exports.apiEndpointQuestion = exports.ApiNameQuestion = exports.ComponentsQuestion = exports.BaseQuestionService = void 0;
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const constants_1 = require("./constants");
const localizeUtils_1 = require("../../../common/localizeUtils");
const checker_1 = require("./checker");
const depsHandler_1 = require("./depsHandler");
const utils_1 = require("./utils");
const result_1 = require("./result");
const errors_1 = require("./errors");
const projectSettingsHelperV3_1 = require("../../../common/projectSettingsHelperV3");
const telemetry_1 = require("./telemetry");
class BaseQuestionService {
    constructor(telemetryReporter, logger) {
        this.telemetryReporter = telemetryReporter;
        this.logger = logger;
    }
}
exports.BaseQuestionService = BaseQuestionService;
class ComponentsQuestion extends BaseQuestionService {
    constructor(ctx, inputs, telemetryReporter, logger) {
        super(telemetryReporter, logger);
        this.ctx = ctx;
        telemetry_1.TelemetryUtils.init(ctx.telemetryReporter);
        this.projectPath = inputs.projectPath;
        this.components = [];
        if (inputs.platform === teamsfx_api_1.Platform.CLI_HELP) {
            this.components.push(exports.botOption);
            this.components.push(exports.functionOption);
        }
        else {
            if (projectSettingsHelperV3_1.hasBot(ctx.projectSetting)) {
                this.components.push(exports.botOption);
            }
            if (projectSettingsHelperV3_1.hasApi(ctx.projectSetting)) {
                this.components.push(exports.functionOption);
            }
            if (this.components.length === 0) {
                throw result_1.ResultFactory.UserError(errors_1.ErrorMessage.NoValidCompoentExistError.name, errors_1.ErrorMessage.NoValidCompoentExistError.message());
            }
        }
    }
    getQuestion() {
        return {
            type: "multiSelect",
            name: constants_1.Constants.questionKey.componentsSelect,
            title: localizeUtils_1.getLocalizedString("plugins.apiConnector.whichService.title"),
            staticOptions: this.components,
            onDidChangeSelection: async (currentSelectedIds) => {
                var _a;
                if (!this.ctx || !this.projectPath) {
                    return currentSelectedIds;
                }
                for (const item of currentSelectedIds) {
                    try {
                        await depsHandler_1.DepsHandler.checkDepsVerSupport(this.projectPath, item);
                    }
                    catch (err) {
                        const errMsg = err.message;
                        (_a = this.ctx.userInteraction) === null || _a === void 0 ? void 0 : _a.showMessage("warn", errMsg, false, "OK", utils_1.Notification.READ_MORE);
                        currentSelectedIds.delete(item);
                        // this only send on vscode extension
                        utils_1.sendErrorTelemetry(err, telemetry_1.Telemetry.stage.questionModel);
                    }
                }
                return currentSelectedIds;
            },
            validation: {
                validFunc: async (inputs, previousInputs) => {
                    const projectPath = previousInputs === null || previousInputs === void 0 ? void 0 : previousInputs.projectPath;
                    for (const item of inputs) {
                        try {
                            await depsHandler_1.DepsHandler.checkDepsVerSupport(projectPath, item);
                        }
                        catch (err) {
                            // this only send on cli
                            utils_1.sendErrorTelemetry(err, telemetry_1.Telemetry.stage.questionModel);
                            return err.message;
                        }
                    }
                    return checker_1.checkEmptySelect(inputs);
                },
            },
            placeholder: localizeUtils_1.getLocalizedString("plugins.apiConnector.whichService.placeholder"), // Use the placeholder to display some description
        };
    }
}
exports.ComponentsQuestion = ComponentsQuestion;
class ApiNameQuestion extends BaseQuestionService {
    constructor(ctx, telemetryReporter, logger) {
        super(telemetryReporter, logger);
        this.ctx = ctx;
    }
    getQuestion() {
        return {
            type: "text",
            name: constants_1.Constants.questionKey.apiName,
            title: localizeUtils_1.getLocalizedString("plugins.apiConnector.getQuestionApiName.title"),
            placeholder: localizeUtils_1.getLocalizedString("plugins.apiConnector.getQuestionApiName.placeholder"),
            validation: {
                validFunc: async (input, previousInputs) => {
                    var _a;
                    const languageType = (_a = this.ctx) === null || _a === void 0 ? void 0 : _a.projectSetting.programmingLanguage;
                    const components = previousInputs[constants_1.Constants.questionKey.componentsSelect];
                    return ((await checker_1.checkEmptyValue(input)) ||
                        (await checker_1.checkApiNameExist(input, previousInputs === null || previousInputs === void 0 ? void 0 : previousInputs.projectPath, components, languageType)) ||
                        checker_1.checkApiNameValid(input));
                },
            },
        };
    }
}
exports.ApiNameQuestion = ApiNameQuestion;
exports.apiEndpointQuestion = {
    name: constants_1.Constants.questionKey.endpoint,
    title: localizeUtils_1.getLocalizedString("plugins.apiConnector.getQuestionEndpoint.title"),
    type: "text",
    placeholder: localizeUtils_1.getLocalizedString("plugins.apiConnector.getQuestionEndpoint.placeholder"),
    validation: {
        validFunc: checker_1.checkHttp,
    },
    forgetLastValue: true,
};
exports.basicAuthUsernameQuestion = {
    name: constants_1.Constants.questionKey.apiUserName,
    title: localizeUtils_1.getLocalizedString("plugins.apiConnector.getQuestion.basicAuth.userName.title"),
    type: "text",
    placeholder: localizeUtils_1.getLocalizedString("plugins.apiConnector.getQuestion.basicAuth.userName.placeholder"),
    validation: {
        validFunc: checker_1.checkEmptyValue,
    },
};
exports.appTenantIdQuestion = {
    name: constants_1.Constants.questionKey.apiAppTenentId,
    title: localizeUtils_1.getLocalizedString("plugins.apiConnector.appTenantId.title"),
    type: "text",
    placeholder: localizeUtils_1.getLocalizedString("plugins.apiConnector.appTenantId.placeholder"),
    validation: {
        validFunc: checker_1.checkIsGuid,
    },
};
exports.appIdQuestion = {
    name: constants_1.Constants.questionKey.apiAppId,
    title: localizeUtils_1.getLocalizedString("plugins.apiConnector.appId.title"),
    type: "text",
    placeholder: localizeUtils_1.getLocalizedString("plugins.apiConnector.appId.placeholder"),
    validation: {
        validFunc: checker_1.checkIsGuid,
    },
};
function buildAPIKeyNameQuestion() {
    return {
        name: constants_1.Constants.questionKey.apiAPIKeyName,
        title: localizeUtils_1.getLocalizedString("plugins.apiConnector.getQuestion.apiKeyName.title"),
        type: "text",
        placeholder: localizeUtils_1.getLocalizedString("plugins.apiConnector.getQuestion.apiKeyName.placeholder"),
        validation: {
            validFunc: checker_1.checkEmptyValue,
        },
    };
}
exports.buildAPIKeyNameQuestion = buildAPIKeyNameQuestion;
exports.reuseAppOption = {
    id: "existing",
    label: localizeUtils_1.getLocalizedString("plugins.apiConnector.reuseAppOption.title"),
};
exports.anotherAppOption = {
    id: "custom",
    label: localizeUtils_1.getLocalizedString("plugins.apiConnector.anotherAppOption.title"),
};
exports.requestHeaderOption = {
    id: "header",
    label: localizeUtils_1.getLocalizedString("plugins.apiConnector.requestHeaderOption.title"),
};
exports.queryParamsOption = {
    id: "querystring",
    label: localizeUtils_1.getLocalizedString("plugins.apiConnector.queryParamsOption.title"),
};
exports.botOption = {
    id: "bot",
    label: localizeUtils_1.getLocalizedString("plugins.apiConnector.botOption.title"),
    detail: "./bot",
};
exports.functionOption = {
    id: "api",
    label: localizeUtils_1.getLocalizedString("plugins.apiConnector.functionOption.title"),
    detail: "./api",
};
exports.BasicAuthOption = {
    id: constants_1.AuthType.BASIC,
    label: "Basic",
    detail: localizeUtils_1.getLocalizedString("plugins.apiConnector.BasicAuthOption.detail"),
};
exports.CertAuthOption = {
    id: constants_1.AuthType.CERT,
    label: "Certification",
    detail: localizeUtils_1.getLocalizedString("plugins.apiConnector.CertAuthOption.detail"),
};
exports.AADAuthOption = {
    id: constants_1.AuthType.AAD,
    label: "Azure Active Directory",
    detail: localizeUtils_1.getLocalizedString("plugins.apiConnector.AADAuthOption.detail"),
};
exports.APIKeyAuthOption = {
    id: constants_1.AuthType.APIKEY,
    label: "API Key",
    detail: localizeUtils_1.getLocalizedString("plugins.apiConnector.APIKeyOption.detail"),
};
exports.ImplementMyselfOption = {
    id: constants_1.AuthType.CUSTOM,
    label: "Custom Auth Implementation",
    detail: localizeUtils_1.getLocalizedString("plugins.apiConnector.ImplementMyselfOption.detail"),
};
//# sourceMappingURL=questions.js.map