"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.mapToFuncToolsVersion = exports.FuncToolChecker = exports.FuncVersion = void 0;
const tslib_1 = require("tslib");
const fs = tslib_1.__importStar(require("fs-extra"));
const path = tslib_1.__importStar(require("path"));
const os = tslib_1.__importStar(require("os"));
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const helpLink_1 = require("../constant/helpLink");
const progressIndicator_1 = require("../util/progressIndicator");
const depsError_1 = require("../depsError");
const cpUtils_1 = require("../util/cpUtils");
const system_1 = require("../util/system");
const telemetry_1 = require("../constant/telemetry");
const depsChecker_1 = require("../depsChecker");
const message_1 = require("../constant/message");
const nodeChecker_1 = require("./nodeChecker");
var FuncVersion;
(function (FuncVersion) {
    FuncVersion["v1"] = "1";
    FuncVersion["v2"] = "2";
    FuncVersion["v3"] = "3";
    FuncVersion["v4"] = "4";
})(FuncVersion = exports.FuncVersion || (exports.FuncVersion = {}));
const FuncNodeVersionWhiteList = {
    // func-core-tools version
    "3": {
        "10": true,
        "12": true,
        "14": true,
    },
    "4": {
        "14": true,
        "16": true,
        "18": true,
    },
};
const RecommendedNodeVersion = "16";
const funcPackageName = "azure-functions-core-tools";
const funcToolName = "Azure Functions Core Tools";
const installVersion = FuncVersion.v4;
const supportedVersions = [FuncVersion.v4];
const displayFuncName = `${funcToolName} (v${FuncVersion.v4})`;
const timeout = 5 * 60 * 1000;
class FuncToolChecker {
    constructor(logger, telemetry) {
        this._logger = logger;
        this._telemetry = telemetry;
    }
    async getDepsInfo(isPortableFuncInstalled, isGlobalFuncInstalled, error) {
        return Promise.resolve({
            name: funcToolName,
            type: depsChecker_1.DepsType.FuncCoreTools,
            isInstalled: isPortableFuncInstalled || isGlobalFuncInstalled,
            command: await this.command(isPortableFuncInstalled, isGlobalFuncInstalled),
            details: {
                isLinuxSupported: false,
                installVersion: installVersion,
                supportedVersions: supportedVersions,
                binFolders: isPortableFuncInstalled ? this.getPortableFuncBinFolders() : undefined,
            },
            error: error,
        });
    }
    async resolve() {
        let installationInfo;
        try {
            const nodeVersion = await this.getNodeVersion();
            installationInfo = await this.getInstallationInfo();
            if (!installationInfo.isInstalled) {
                await this.install();
                installationInfo = await this.getInstallationInfo();
            }
            if (!installationInfo.error && installationInfo.portableFunc.isInstalled) {
                const portableFuncNodeError = await this.checkPortableFuncAndNode(installationInfo.portableFunc, nodeVersion);
                if (portableFuncNodeError) {
                    installationInfo.isInstalled = false;
                    installationInfo.error = portableFuncNodeError;
                }
            }
            if (!installationInfo.error) {
                const globalFuncNodeError = await this.checkGlobalFuncAndNode(installationInfo.globalFunc, nodeVersion);
                if (globalFuncNodeError) {
                    installationInfo.error = globalFuncNodeError;
                    if (!installationInfo.portableFunc.isInstalled &&
                        installationInfo.globalFunc.isInstalled) {
                        installationInfo.isInstalled = false;
                    }
                }
            }
        }
        catch (error) {
            await this._logger.printDetailLog();
            await this._logger.error(`${error.message}, error = '${error}'`);
            if (error instanceof depsError_1.DepsCheckerError) {
                return await this.getDepsInfo(false, false, error);
            }
            return await this.getDepsInfo(false, false, new depsError_1.DepsCheckerError(error.message, helpLink_1.defaultHelpLink));
        }
        finally {
            this._logger.cleanup();
        }
        return installationInfo;
    }
    async getInstallationInfo() {
        var _a;
        const globalFunc = await this.checkGlobalFuncVersion();
        const isGlobalFuncInstalled = globalFunc.isInstalled;
        const portableFunc = await this.checkPortableFuncVersion();
        const isPortableFuncInstalled = portableFunc.isInstalled;
        if (isGlobalFuncInstalled) {
            this._telemetry.sendEvent(telemetry_1.DepsCheckerEvent.funcAlreadyInstalled, {
                "global-func-version": (_a = globalFunc.funcVersion) !== null && _a !== void 0 ? _a : "",
            });
            if (!isPortableFuncInstalled) {
                await this.cleanup();
            }
        }
        if (isPortableFuncInstalled) {
            // avoid missing this event after first installation 60 days
            this._telemetry.sendEvent(telemetry_1.DepsCheckerEvent.funcInstallCompleted);
        }
        const depsInfo = await this.getDepsInfo(isPortableFuncInstalled, isGlobalFuncInstalled);
        return Object.assign(depsInfo, { globalFunc: globalFunc, portableFunc: portableFunc });
    }
    async getNodeVersion() {
        var _a;
        const nodeVersion = (_a = (await nodeChecker_1.NodeChecker.getInstalledNodeVersion())) === null || _a === void 0 ? void 0 : _a.majorVersion;
        if (!nodeVersion) {
            throw new depsError_1.NodeNotFoundError(message_1.Messages.NodeNotFound.split("@NodeVersion").join(supportedVersions[supportedVersions.length - 1]), helpLink_1.nodeNotFoundHelpLink);
        }
        return nodeVersion;
    }
    async checkPortableFuncAndNode(portableFunc, nodeVersion) {
        var _a;
        if (portableFunc.funcVersion) {
            if (!((_a = FuncNodeVersionWhiteList[portableFunc.funcVersion.toString()]) === null || _a === void 0 ? void 0 : _a[nodeVersion])) {
                return new depsError_1.PortableFuncNodeNotMatchedError(message_1.Messages.portableFuncNodeNotMatched
                    .split("@FuncVersion")
                    .join(`v${portableFunc.funcVersion}`)
                    .split("@NodeVersion")
                    .join(`v${nodeVersion}`)
                    .split("@Link")
                    .join(helpLink_1.nodeInstallationLink)
                    .split("@RecommendedVersion")
                    .join(`v${RecommendedNodeVersion}`), helpLink_1.functionDepsVersionsLink);
            }
        }
        return undefined;
    }
    async checkGlobalFuncAndNode(globalFunc, nodeVersion) {
        var _a;
        if (globalFunc.funcVersion) {
            if (!((_a = FuncNodeVersionWhiteList[globalFunc.funcVersion.toString()]) === null || _a === void 0 ? void 0 : _a[nodeVersion])) {
                return new depsError_1.GlobalFuncNodeNotMatchedError(message_1.Messages.globalFuncNodeNotMatched
                    .split("@FuncVersion")
                    .join(`v${globalFunc.funcVersion.toString()}`)
                    .split("@NodeVersion")
                    .join(`v${nodeVersion}`)
                    .split("@link")
                    .join(helpLink_1.functionDepsVersionsLink), helpLink_1.functionDepsVersionsLink);
            }
        }
        return undefined;
    }
    async checkPortableFuncVersion() {
        let isVersionSupported = false, hasSentinel = false;
        let portableFuncVersion = null;
        try {
            portableFuncVersion = await this.queryFuncVersion(FuncToolChecker.getPortableFuncExecPath());
            isVersionSupported =
                portableFuncVersion !== null && supportedVersions.includes(portableFuncVersion);
            // to avoid "func -v" and "func new" work well, but "func start" fail.
            hasSentinel = await fs.pathExists(FuncToolChecker.getSentinelPath());
            if (system_1.isWindows() && isVersionSupported && hasSentinel) {
                await this.cleanupPortablePs1();
            }
        }
        catch (error) {
            // do nothing
            return {
                isInstalled: false,
                funcVersion: portableFuncVersion,
            };
        }
        return {
            isInstalled: isVersionSupported && hasSentinel,
            funcVersion: portableFuncVersion,
        };
    }
    async checkGlobalFuncVersion() {
        const globalFuncVersion = await this.queryGlobalFuncVersion();
        return {
            isInstalled: globalFuncVersion !== null && supportedVersions.includes(globalFuncVersion),
            funcVersion: globalFuncVersion,
        };
    }
    async install() {
        if (system_1.isLinux()) {
            throw new depsError_1.LinuxNotSupportedError(message_1.Messages.linuxDepsNotFound.split("@SupportedPackages").join(displayFuncName), helpLink_1.defaultHelpLink);
        }
        if (!(await this.hasNPM())) {
            this.handleNpmNotFound();
        }
        await this.cleanup();
        await this.installFunc();
        if (!(await this.validate())) {
            await this.handleInstallFuncFailed();
        }
        this._telemetry.sendEvent(telemetry_1.DepsCheckerEvent.funcInstallCompleted);
        await this._logger.info(message_1.Messages.finishInstallFunctionCoreTool.replace("@NameVersion", displayFuncName));
    }
    async handleInstallFuncFailed() {
        await this.cleanup();
        this._telemetry.sendSystemErrorEvent(telemetry_1.DepsCheckerEvent.funcInstallError, telemetry_1.TelemtryMessages.failedToInstallFunc, message_1.Messages.failToValidateFuncCoreTool.replace("@NameVersion", displayFuncName));
        throw new depsError_1.DepsCheckerError(message_1.Messages.failToInstallFuncCoreTool.split("@NameVersion").join(displayFuncName), helpLink_1.defaultHelpLink);
    }
    async validate() {
        let isVersionSupported = false;
        let hasSentinel = false;
        try {
            const portableFunc = await this.queryFuncVersion(FuncToolChecker.getPortableFuncExecPath());
            isVersionSupported = portableFunc !== null && supportedVersions.includes(portableFunc);
            // to avoid "func -v" and "func new" work well, but "func start" fail.
            hasSentinel = await fs.pathExists(FuncToolChecker.getSentinelPath());
        }
        catch (err) {
            this._telemetry.sendSystemErrorEvent(telemetry_1.DepsCheckerEvent.funcValidationError, telemetry_1.TelemtryMessages.failedToValidateFunc, err);
        }
        if (!isVersionSupported || !hasSentinel) {
            this._telemetry.sendEvent(telemetry_1.DepsCheckerEvent.funcValidationError, {
                "func-v": String(isVersionSupported),
                sentinel: String(hasSentinel),
            });
        }
        return isVersionSupported && hasSentinel;
    }
    handleNpmNotFound() {
        this._telemetry.sendEvent(telemetry_1.DepsCheckerEvent.npmNotFound);
        throw new depsError_1.DepsCheckerError(message_1.Messages.needInstallFuncCoreTool.replace("@NameVersion", displayFuncName), helpLink_1.defaultHelpLink);
    }
    static getDefaultInstallPath() {
        return path.join(os.homedir(), `.${teamsfx_api_1.ConfigFolderName}`, "bin", "func");
    }
    static getSentinelPath() {
        return path.join(os.homedir(), `.${teamsfx_api_1.ConfigFolderName}`, "func-sentinel");
    }
    static getPortableFuncExecPath() {
        return path.join(FuncToolChecker.getDefaultInstallPath(), "node_modules", "azure-functions-core-tools", "lib", "main.js");
    }
    async command(isPortableFuncInstalled, isGlobalFuncInstalled) {
        if (isPortableFuncInstalled) {
            return `node "${FuncToolChecker.getPortableFuncExecPath()}"`;
        }
        if (isGlobalFuncInstalled) {
            return "func";
        }
        return "npx azure-functions-core-tools@3";
    }
    getPortableFuncBinFolders() {
        return [
            FuncToolChecker.getDefaultInstallPath(),
            path.join(FuncToolChecker.getDefaultInstallPath(), "node_modules", ".bin"),
        ];
    }
    async queryFuncVersion(path) {
        const output = await cpUtils_1.cpUtils.executeCommand(undefined, this._logger, { shell: true }, "node", `"${path}"`, "--version");
        return mapToFuncToolsVersion(output);
    }
    async queryGlobalFuncVersion() {
        try {
            const output = await cpUtils_1.cpUtils.executeCommand(undefined, this._logger, 
            // same as backend start, avoid powershell execution policy issue.
            { shell: system_1.isWindows() ? "cmd.exe" : true }, "func", "--version");
            return mapToFuncToolsVersion(output);
        }
        catch (error) {
            return null;
        }
    }
    async hasNPM() {
        try {
            const npmVersion = await cpUtils_1.cpUtils.executeCommand(undefined, this._logger, { shell: true }, "npm", "--version");
            this._telemetry.sendEvent(telemetry_1.DepsCheckerEvent.npmAlreadyInstalled, {
                "npm-version": npmVersion,
            });
            return true;
        }
        catch (error) {
            this._telemetry.sendEvent(telemetry_1.DepsCheckerEvent.npmNotFound);
            return false;
        }
    }
    async cleanup() {
        try {
            await fs.emptyDir(FuncToolChecker.getDefaultInstallPath());
            await fs.remove(FuncToolChecker.getSentinelPath());
        }
        catch (err) {
            await this._logger.debug(`Failed to clean up path: ${FuncToolChecker.getDefaultInstallPath()}, error: ${err}`);
        }
    }
    async cleanupPortablePs1() {
        // delete func.ps1 from portable function
        for (const funcFolder of this.getPortableFuncBinFolders()) {
            const funcPath = path.join(funcFolder, "func.ps1");
            if (await fs.pathExists(funcPath)) {
                await this._logger.debug(`deleting func.ps1 from ${funcPath}`);
                await fs.remove(funcPath);
            }
        }
    }
    async installFunc() {
        await this._telemetry.sendEventWithDuration(telemetry_1.DepsCheckerEvent.funcInstallScriptCompleted, async () => {
            await progressIndicator_1.runWithProgressIndicator(async () => await this.doInstallPortableFunc(FuncVersion.v4), this._logger);
        });
    }
    async doInstallPortableFunc(version) {
        await this._logger.info(message_1.Messages.startInstallFunctionCoreTool.replace("@NameVersion", displayFuncName));
        try {
            await cpUtils_1.cpUtils.executeCommand(undefined, this._logger, { timeout: timeout, shell: false }, this.getExecCommand("npm"), "install", 
            // not use -f, to avoid npm@6 bug: exit code = 0, even if install fail
            `${funcPackageName}@${version}`, "--prefix", `${FuncToolChecker.getDefaultInstallPath()}`, "--no-audit");
            await fs.ensureFile(FuncToolChecker.getSentinelPath());
            if (system_1.isWindows()) {
                // delete func.ps1 if exists to workaround the powershell execution policy issue:
                // https://github.com/npm/cli/issues/470
                const funcPSScript = await this.getFuncPSScriptPath();
                if (await fs.pathExists(funcPSScript)) {
                    await this._logger.debug(`deleting func.ps1 from ${funcPSScript}`);
                    await fs.remove(funcPSScript);
                }
                await this.cleanupPortablePs1();
            }
        }
        catch (error) {
            this._telemetry.sendSystemErrorEvent(telemetry_1.DepsCheckerEvent.funcInstallScriptError, telemetry_1.TelemtryMessages.failedToInstallFunc, error);
        }
    }
    getExecCommand(command) {
        return system_1.isWindows() ? `${command}.cmd` : command;
    }
    async getFuncPSScriptPath() {
        try {
            const output = await cpUtils_1.cpUtils.executeCommand(undefined, this._logger, {
                shell: "cmd.exe",
            }, "where", "func");
            const funcPath = output.split(/\r?\n/)[0];
            const funcFolder = path.dirname(funcPath);
            return path.join(funcFolder, "func.ps1");
        }
        catch (_a) {
            // ignore error and regard func.ps1 as not found.
            return "";
        }
    }
}
exports.FuncToolChecker = FuncToolChecker;
function mapToFuncToolsVersion(output) {
    var _a;
    const regex = /(?<major_version>\d+)\.(?<minor_version>\d+)\.(?<patch_version>\d+)/gm;
    const match = regex.exec(output);
    if (!match) {
        return null;
    }
    switch ((_a = match.groups) === null || _a === void 0 ? void 0 : _a.major_version) {
        case FuncVersion.v1:
            return FuncVersion.v1;
        case FuncVersion.v2:
            return FuncVersion.v2;
        case FuncVersion.v3:
            return FuncVersion.v3;
        case FuncVersion.v4:
            return FuncVersion.v4;
        default:
            return null;
    }
}
exports.mapToFuncToolsVersion = mapToFuncToolsVersion;
//# sourceMappingURL=funcToolChecker.js.map