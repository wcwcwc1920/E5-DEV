"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.migratePrepareManifest = exports.migrateSetUpSSO = exports.migrateSetUpBot = exports.migrateSetUpTab = exports.migrateTransparentNpmInstall = exports.migrateTransparentLocalTunnel = exports.migrateTransparentPrerequisite = void 0;
const comment_json_1 = require("comment-json");
const local_1 = require("../../../../common/local");
const debugV3MigrationUtils_1 = require("./debugV3MigrationUtils");
function migrateTransparentPrerequisite(context) {
    for (const task of context.tasks) {
        if (!debugV3MigrationUtils_1.isCommentObject(task) ||
            !(task["type"] === "teamsfx") ||
            !(task["command"] === local_1.TaskCommand.checkPrerequisites)) {
            continue;
        }
        if (debugV3MigrationUtils_1.isCommentObject(task["args"]) && debugV3MigrationUtils_1.isCommentArray(task["args"]["prerequisites"])) {
            const newPrerequisites = [];
            const toolsArgs = {};
            for (const prerequisite of task["args"]["prerequisites"]) {
                if (prerequisite === local_1.Prerequisite.nodejs) {
                    newPrerequisites.push(`"${local_1.Prerequisite.nodejs}", // Validate if Node.js is installed.`);
                }
                else if (prerequisite === local_1.Prerequisite.m365Account) {
                    newPrerequisites.push(`"${local_1.Prerequisite.m365Account}", // Sign-in prompt for Microsoft 365 account, then validate if the account enables the sideloading permission.`);
                }
                else if (prerequisite === local_1.Prerequisite.portOccupancy) {
                    newPrerequisites.push(`"${local_1.Prerequisite.portOccupancy}", // Validate available ports to ensure those debug ones are not occupied.`);
                }
                else if (prerequisite === local_1.Prerequisite.func) {
                    toolsArgs.func = true;
                }
                else if (prerequisite === local_1.Prerequisite.devCert) {
                    toolsArgs.devCert = { trust: true };
                }
                else if (prerequisite === local_1.Prerequisite.dotnet) {
                    toolsArgs.dotnet = true;
                }
            }
            task["args"]["prerequisites"] = comment_json_1.parse(`[
        ${newPrerequisites.join("\n  ")}
      ]`);
            if (Object.keys(toolsArgs).length > 0) {
                if (!context.appYmlConfig.deploy) {
                    context.appYmlConfig.deploy = {};
                }
                context.appYmlConfig.deploy.tools = toolsArgs;
            }
        }
    }
}
exports.migrateTransparentPrerequisite = migrateTransparentPrerequisite;
function migrateTransparentLocalTunnel(context) {
    for (const task of context.tasks) {
        if (!debugV3MigrationUtils_1.isCommentObject(task) ||
            !(task["type"] === "teamsfx") ||
            !(task["command"] === local_1.TaskCommand.startLocalTunnel)) {
            continue;
        }
        if (debugV3MigrationUtils_1.isCommentObject(task["args"])) {
            const comment = `
        {
          // Keep consistency with migrated configuration.
        }
      `;
            task["args"]["env"] = "local";
            task["args"]["output"] = comment_json_1.assign(comment_json_1.parse(comment), {
                endpoint: context.placeholderMapping.botEndpoint,
                domain: context.placeholderMapping.botDomain,
            });
        }
    }
}
exports.migrateTransparentLocalTunnel = migrateTransparentLocalTunnel;
function migrateTransparentNpmInstall(context) {
    let index = 0;
    while (index < context.tasks.length) {
        const task = context.tasks[index];
        if (!debugV3MigrationUtils_1.isCommentObject(task) ||
            !(task["type"] === "teamsfx") ||
            !(task["command"] === local_1.TaskCommand.npmInstall)) {
            ++index;
            continue;
        }
        if (debugV3MigrationUtils_1.isCommentObject(task["args"]) && debugV3MigrationUtils_1.isCommentArray(task["args"]["projects"])) {
            for (const npmArgs of task["args"]["projects"]) {
                if (!debugV3MigrationUtils_1.isCommentObject(npmArgs) || !(typeof npmArgs["cwd"] === "string")) {
                    continue;
                }
                const npmInstallArg = { args: "install" };
                npmInstallArg.workingDirectory = npmArgs["cwd"].replace("${workspaceFolder}", ".");
                if (typeof npmArgs["npmInstallArgs"] === "string") {
                    npmInstallArg.args = `install ${npmArgs["npmInstallArgs"]}`;
                }
                else if (debugV3MigrationUtils_1.isCommentArray(npmArgs["npmInstallArgs"]) &&
                    npmArgs["npmInstallArgs"].length > 0) {
                    npmInstallArg.args = `install ${npmArgs["npmInstallArgs"].join(" ")}`;
                }
                if (!context.appYmlConfig.deploy) {
                    context.appYmlConfig.deploy = {};
                }
                if (!context.appYmlConfig.deploy.npmCommands) {
                    context.appYmlConfig.deploy.npmCommands = [];
                }
                context.appYmlConfig.deploy.npmCommands.push(npmInstallArg);
            }
        }
        if (typeof task["label"] === "string") {
            // TODO: remove preLaunchTask in launch.json
            replaceInDependsOn(task["label"], context.tasks);
        }
        context.tasks.splice(index, 1);
    }
}
exports.migrateTransparentNpmInstall = migrateTransparentNpmInstall;
function migrateSetUpTab(context) {
    let index = 0;
    while (index < context.tasks.length) {
        const task = context.tasks[index];
        if (!debugV3MigrationUtils_1.isCommentObject(task) ||
            !(task["type"] === "teamsfx") ||
            !(task["command"] === local_1.TaskCommand.setUpTab)) {
            ++index;
            continue;
        }
        if (typeof task["label"] !== "string") {
            ++index;
            continue;
        }
        let url = new URL("https://localhost:53000");
        if (debugV3MigrationUtils_1.isCommentObject(task["args"]) && typeof task["args"]["baseUrl"] === "string") {
            try {
                url = new URL(task["args"]["baseUrl"]);
            }
            catch (_a) { }
        }
        if (!context.appYmlConfig.configureApp) {
            context.appYmlConfig.configureApp = {};
        }
        if (!context.appYmlConfig.configureApp.tab) {
            context.appYmlConfig.configureApp.tab = {};
        }
        context.appYmlConfig.configureApp.tab.domain = url.host;
        context.appYmlConfig.configureApp.tab.endpoint = url.origin;
        if (!context.appYmlConfig.deploy) {
            context.appYmlConfig.deploy = {};
        }
        if (!context.appYmlConfig.deploy.tab) {
            context.appYmlConfig.deploy.tab = {};
        }
        context.appYmlConfig.deploy.tab.port = parseInt(url.port);
        const label = task["label"];
        index = handleProvisionAndDeploy(context, index, label);
    }
}
exports.migrateSetUpTab = migrateSetUpTab;
function migrateSetUpBot(context) {
    let index = 0;
    while (index < context.tasks.length) {
        const task = context.tasks[index];
        if (!debugV3MigrationUtils_1.isCommentObject(task) ||
            !(task["type"] === "teamsfx") ||
            !(task["command"] === local_1.TaskCommand.setUpBot)) {
            ++index;
            continue;
        }
        if (typeof task["label"] !== "string") {
            ++index;
            continue;
        }
        if (!context.appYmlConfig.provision) {
            context.appYmlConfig.provision = {};
        }
        context.appYmlConfig.provision.bot = true;
        if (!context.appYmlConfig.deploy) {
            context.appYmlConfig.deploy = {};
        }
        context.appYmlConfig.deploy.bot = true;
        const label = task["label"];
        index = handleProvisionAndDeploy(context, index, label);
    }
}
exports.migrateSetUpBot = migrateSetUpBot;
function migrateSetUpSSO(context) {
    let index = 0;
    while (index < context.tasks.length) {
        const task = context.tasks[index];
        if (!debugV3MigrationUtils_1.isCommentObject(task) ||
            !(task["type"] === "teamsfx") ||
            !(task["command"] === local_1.TaskCommand.setUpSSO)) {
            ++index;
            continue;
        }
        if (typeof task["label"] !== "string") {
            ++index;
            continue;
        }
        if (!context.appYmlConfig.registerApp) {
            context.appYmlConfig.registerApp = {};
        }
        context.appYmlConfig.registerApp.aad = true;
        if (!context.appYmlConfig.configureApp) {
            context.appYmlConfig.configureApp = {};
        }
        context.appYmlConfig.configureApp.aad = true;
        if (!context.appYmlConfig.deploy) {
            context.appYmlConfig.deploy = {};
        }
        context.appYmlConfig.deploy.sso = true;
        const label = task["label"];
        index = handleProvisionAndDeploy(context, index, label);
    }
}
exports.migrateSetUpSSO = migrateSetUpSSO;
function migratePrepareManifest(context) {
    let index = 0;
    while (index < context.tasks.length) {
        const task = context.tasks[index];
        if (!debugV3MigrationUtils_1.isCommentObject(task) ||
            !(task["type"] === "teamsfx") ||
            !(task["command"] === local_1.TaskCommand.prepareManifest)) {
            ++index;
            continue;
        }
        if (typeof task["label"] !== "string") {
            ++index;
            continue;
        }
        let appPackagePath = undefined;
        if (debugV3MigrationUtils_1.isCommentObject(task["args"]) && typeof task["args"]["appPackagePath"] === "string") {
            appPackagePath = task["args"]["appPackagePath"];
        }
        if (!appPackagePath) {
            if (!context.appYmlConfig.registerApp) {
                context.appYmlConfig.registerApp = {};
            }
            context.appYmlConfig.registerApp.teamsApp = true;
        }
        if (!context.appYmlConfig.configureApp) {
            context.appYmlConfig.configureApp = {};
        }
        if (!context.appYmlConfig.configureApp.teamsApp) {
            context.appYmlConfig.configureApp.teamsApp = {};
        }
        context.appYmlConfig.configureApp.teamsApp.appPackagePath = appPackagePath;
        const label = task["label"];
        index = handleProvisionAndDeploy(context, index, label);
    }
}
exports.migratePrepareManifest = migratePrepareManifest;
function handleProvisionAndDeploy(context, index, label) {
    context.tasks.splice(index, 1);
    const existingLabels = getLabels(context.tasks);
    const generatedBefore = context.generatedLabels.find((value) => value.startsWith("Create resources"));
    const createResourcesLabel = generatedBefore || debugV3MigrationUtils_1.generateLabel("Create resources", existingLabels);
    const setUpLocalProjectsLabel = context.generatedLabels.find((value) => value.startsWith("Set up local projects")) ||
        debugV3MigrationUtils_1.generateLabel("Set up local projects", existingLabels);
    if (!generatedBefore) {
        context.generatedLabels.push(createResourcesLabel);
        const createResources = debugV3MigrationUtils_1.createResourcesTask(createResourcesLabel);
        context.tasks.splice(index, 0, createResources);
        ++index;
        context.generatedLabels.push(setUpLocalProjectsLabel);
        const setUpLocalProjects = debugV3MigrationUtils_1.setUpLocalProjectsTask(setUpLocalProjectsLabel);
        context.tasks.splice(index, 0, setUpLocalProjects);
        ++index;
    }
    replaceInDependsOn(label, context.tasks, createResourcesLabel, setUpLocalProjectsLabel);
    return index;
}
function replaceInDependsOn(label, tasks, ...replacements) {
    for (const task of tasks) {
        if (debugV3MigrationUtils_1.isCommentObject(task) && task["dependsOn"]) {
            if (typeof task["dependsOn"] === "string") {
                if (task["dependsOn"] === label) {
                    if (replacements.length > 0) {
                        task["dependsOn"] = new comment_json_1.CommentArray(...replacements);
                    }
                    else {
                        delete task["dependsOn"];
                    }
                }
            }
            else if (Array.isArray(task["dependsOn"])) {
                const index = task["dependsOn"].findIndex((value) => value === label);
                if (index !== -1) {
                    if (replacements.length > 0 && !task["dependsOn"].includes(replacements[0])) {
                        task["dependsOn"].splice(index, 1, ...replacements);
                    }
                    else {
                        task["dependsOn"].splice(index, 1);
                    }
                }
            }
        }
    }
}
function getLabels(tasks) {
    const labels = [];
    for (const task of tasks) {
        if (debugV3MigrationUtils_1.isCommentObject(task) && typeof task["label"] === "string") {
            labels.push(task["label"]);
        }
    }
    return labels;
}
//# sourceMappingURL=taskMigrator.js.map